# 作業一 — Problem 1

學號：41143263  

---

## 解題說明

本題要求實作 **Ackermann 函數 (Ackermann function)**，並提供 **遞迴版本**與 **非遞迴版本**。

Ackermann 函數定義如下：

$$
A(m,n) =
\begin{cases}
n+1 & m = 0 \\
A(m-1, 1) & m > 0, n = 0 \\
A(m-1, A(m, n-1)) & m > 0, n > 0
\end{cases}
$$

---

## 解題策略

1. **遞迴版本**  
   - 直接依照數學定義撰寫，簡潔直觀。  
   - 基底條件為 `m = 0` 或 `n = 0`，其餘情況則透過遞迴呼叫。

2. **非遞迴版本**  
   - 使用自製堆疊 (Stack) 模擬函式呼叫過程。  
   - 避免系統遞迴過深造成 Stack Overflow。  

3. **主程式**  
   - 提供選項讓使用者選擇：  
     - 遞迴版本  
     - 非遞迴版本  
     - 兩者比對結果  

---

## 程式實作

以下為 `ackermann.c` 程式碼 (純 C 實作)：

```c
#include <stdio.h>
#include <stdlib.h>

/* 遞迴版本 */
unsigned long long ack_recursive(unsigned long long m, unsigned long long n) {
    if (m == 0ULL) return n + 1ULL;
    else if (n == 0ULL) return ack_recursive(m - 1ULL, 1ULL);
    else return ack_recursive(m - 1ULL, ack_recursive(m, n - 1ULL));
}

/* 非遞迴版本 */
typedef struct { unsigned long long *data; size_t cap, top; } ULLStack;
void initStack(ULLStack *st){st->data=NULL;st->cap=0;st->top=0;}
void reserve(ULLStack *st,size_t c){if(c<=st->cap)return;unsigned long long*nd=malloc(c*sizeof(unsigned long long));for(size_t i=0;i<st->top;i++)nd[i]=st->data[i];free(st->data);st->data=nd;st->cap=c;}
void push(ULLStack *st,unsigned long long v){if(st->top>=st->cap)reserve(st,st->cap?st->cap*2:1024);st->data[st->top++]=v;}
unsigned long long pop(ULLStack *st){return st->data[--st->top];}
int empty(ULLStack *st){return st->top==0;}
unsigned long long ack_iterative(unsigned long long m,unsigned long long n){
    ULLStack st;initStack(&st);push(&st,m);
    while(!empty(&st)){
        m=pop(&st);
        if(m==0ULL)n=n+1ULL;
        else if(n==0ULL){push(&st,m-1ULL);n=1ULL;}
        else{push(&st,m-1ULL);push(&st,m);n=n-1ULL;}
    }
    free(st.data);return n;
}

/* 主程式 */
int main(){
    unsigned long long m,n;int how;
    printf("輸入 m 與 n：");scanf("%llu %llu",&m,&n);
    printf("選擇計算方式：1) 遞迴  2) 非遞迴  3) 兩者比對\n");
    scanf("%d",&how);
    if(how==1) printf("遞迴結果 = %llu\n",ack_recursive(m,n));
    else if(how==2) printf("非遞迴結果 = %llu\n",ack_iterative(m,n));
    else{unsigned long long a1=ack_recursive(m,n),a2=ack_iterative(m,n);
         printf("遞迴 = %llu, 非遞迴 = %llu\n",a1,a2);}
    return 0;
}

