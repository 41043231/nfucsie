# 41043231

作業(一) Problem 2

## 解題說明
本題要求實作一個程式，產生集合 $S$ 的 Power Set (冪集合)。
若集合 $S$ 共有 $n$ 個元素，則 Power Set 的大小為 $2^n$，包含所有可能的子集合（包含空集合與完整集合）。

<img width="1073" height="214" alt="image" src="https://github.com/user-attachments/assets/c5e2741c-5bb8-4c30-b3fd-671e94e26dcb" />


### 解題策略

1. 數學定義
   每個元素有兩種選擇：要 or 不要。
   因此所有子集合的數量為 $2^n$。
2. 遞迴思路
   設計一個遞迴函式 powerset_dfs(idx)：
      當 idx == n 時，表示已經處理完所有元素，輸出一個子集合。
      否則對於第 idx 個元素，分別嘗試「不選」與「選取」，並進行遞迴。
   遞迴公式：
      𝑃(𝑆)=𝑃(𝑆−{𝑥})∪({𝑥}∪𝑃(𝑆−{𝑥}))
3. 實作細節
   使用一個整數陣列 pick[] 來記錄每個元素是否被選取 (0 = 不選，1 = 選取)。
   遞迴展開後，在每個基底情況輸出對應子集合。
4. 程式流程
   讀取輸入集合的大小 $n$ 與元素內容。
   呼叫遞迴函式列舉所有子集合。
   最後輸出結果。
## 程式實作

以下為程式碼：

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ====== 輔助函數：輸出一個子集合 ======
   - 參數 elems 為元素字串陣列
   - 參數 pick[i] = 1 表示選取第 i 個元素，0 表示不選取
   - n 為元素總數
*/
void print_subset(char **elems, int *pick, int n) {
    printf("(");
    int first = 1; // 控制輸出格式，避免多餘逗號
    for (int i = 0; i < n; ++i) {
        if (pick[i]) { // 若 pick[i] = 1，代表該元素被選取
            if (!first) printf(", "); // 在非第一個元素前加逗號
            printf("%s", elems[i]);
            first = 0;
        }
    }
    printf(")\n");
}

/* ====== 遞迴函數：逐個決定是否選取元素 ======
   - idx: 當前正在處理的元素索引
   - n: 元素總數
   - elems: 存放元素的字串陣列
   - pick: 紀錄當前子集合選擇情況的陣列
*/
void powerset_dfs(int idx, int n, char **elems, int *pick) {
    if (idx == n) { // 遞迴基底條件：所有元素皆處理完畢
        print_subset(elems, pick, n); // 輸出當前子集合
        return;
    }

    // 情況一：不選取 elems[idx]
    pick[idx] = 0;
    powerset_dfs(idx + 1, n, elems, pick);

    // 情況二：選取 elems[idx]
    pick[idx] = 1;
    powerset_dfs(idx + 1, n, elems, pick);
}

/* ====== 主程式 ====== */
int main() {
    int n;
    printf("輸入元素數量：");
    scanf("%d", &n);

    // 配置存放元素字串的陣列 (長度 = n)
    // 注意：若 n=0，仍配置至少一個位置，避免 malloc(0) 的不確定行為
    char **elems = (char**)malloc(sizeof(char*) * (n > 0 ? n : 1));

    // 為每個元素分配字元空間 (最多 63 字元 + '\0')
    for (int i = 0; i < n; ++i) {
        elems[i] = (char*)malloc(64);
    }

    // 輸入元素內容
    printf("請輸入 %d 個元素（以空白分隔）：\n", n);
    for (int i = 0; i < n; ++i) {
        scanf("%s", elems[i]);
    }

    // 配置 pick 陣列，用來記錄每個元素是否被選取
    int *pick = (int*)malloc(sizeof(int) * n);
    for (int i = 0; i < n; ++i) pick[i] = 0;

    // 呼叫遞迴函式，從索引 0 開始生成所有子集合
    printf("\n所有子集合 (Power set)：\n");
    powerset_dfs(0, n, elems, pick);

    // 釋放記憶體，避免記憶體洩漏
    for (int i = 0; i < n; ++i) free(elems[i]);
    free(elems);
    free(pick);

    return 0;
}

```

## 效能分析

1.時間複雜度：$O(n \times 2^n)$
2.空間複雜度：$O(n)$

## 測試與驗證
<img width="309" height="518" alt="image" src="https://github.com/user-attachments/assets/b29e2f42-eb5c-4e95-983a-bfba08d1a960" />



### 測試案例
| 測試案例 | 輸入集合 $S$      | 預期輸出 (Power Set)                                                              | 實際輸出                                                                 |
| ---- | ------------- | ----------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| 測試一  | $S = {A,B}$   | ${\ {}, {A}, {B}, {A,B}\ }$                                                   | `()`, `(B)`, `(A)`, `(A, B)`                                         |
| 測試二  | $S = {1,2,3}$ | 共 $2^3 = 8$ 個子集合 <br> ${\ {}, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}\ }$ | `()`, `(3)`, `(2)`, `(2, 3)`, `(1)`, `(1, 3)`, `(1, 2)`, `(1, 2, 3)` |



### 編譯與執行指令

```shell
$ gcc hw1_2.c -o hw1_2
$ ./hw1_2
```

### 結論

程式能正確計算 Ackermann 函數 $A(m,n)$ 的值。
在小範圍輸入（例如 $m \leq 3$）下，遞迴版與非遞迴版輸出結果一致，驗證程式邏輯正確。
測試案例涵蓋了多種情況（$m=0$、$n=0$、$m,n>0$），有效驗證程式的正確性。
需要注意的是，當 $m$ 或 $n$ 較大時，Ackermann 函數的成長極快，可能導致執行時間過長或記憶體不足。

## 申論及開發報告

### 開發過程中的挑戰

1. 遞迴深度限制
   C 語言的系統堆疊有限，當輸入稍微大一點時
   (例如 $A(4,1)$)，遞迴版本可能會因呼叫深度過高而導致程式崩潰。
3. 非遞迴的實作
   必須手動設計一個堆疊結構，來模擬函式呼叫的展開與回溯。
   如何正確地壓入與彈出參數，是確保計算正確性的關鍵。

3. 效能上的限制
   即使是非遞迴版本，當 $m$ 或 $n$ 過大時，計算步驟依然呈現爆炸性成長。
   因此本程式僅適合用於展示程式設計技巧，而不適合作為實務計算工具。
## 心得
透過本次實作，我更加理解了 遞迴的運作機制，以及 如何用迴圈與堆疊結構來取代遞迴。
Ackermann 函數雖然在實務上幾乎沒有應用，但它是一個很好的教材，能幫助我們清楚看到遞迴深度、空間使用，以及不同實作方式的差異。
這題目的重點不在於「計算多大數字」，而在於體會「遞迴與非遞迴的思維轉換」。
