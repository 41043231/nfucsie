# 41043231

作業(一) Problem 2

## 解題說明
本題要求實作一個程式，產生集合 $S$ 的 Power Set (冪集合)。
若集合 $S$ 共有 $n$ 個元素，則 Power Set 的大小為 $2^n$，包含所有可能的子集合（包含空集合與完整集合）。

<img width="1073" height="214" alt="image" src="https://github.com/user-attachments/assets/c5e2741c-5bb8-4c30-b3fd-671e94e26dcb" />


### 解題策略

1. 數學定義
   每個元素有兩種選擇：要 or 不要。
   因此所有子集合的數量為 $2^n$。
2. 遞迴思路
   設計一個遞迴函式 powerset_dfs(idx)：
      當 idx == n 時，表示已經處理完所有元素，輸出一個子集合。
      否則對於第 idx 個元素，分別嘗試「不選」與「選取」，並進行遞迴。
   遞迴公式：
      𝑃(𝑆)=𝑃(𝑆−{𝑥})∪({𝑥}∪𝑃(𝑆−{𝑥}))
3. 實作細節
   使用一個整數陣列 pick[] 來記錄每個元素是否被選取 (0 = 不選，1 = 選取)。
   遞迴展開後，在每個基底情況輸出對應子集合。
4. 程式流程
   讀取輸入集合的大小 $n$ 與元素內容。
   呼叫遞迴函式列舉所有子集合。
   最後輸出結果。
## 程式實作

以下為程式碼：

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* ====== 輔助函數：輸出一個子集合 ======
   - 參數 elems 為元素字串陣列
   - 參數 pick[i] = 1 表示選取第 i 個元素，0 表示不選取
   - n 為元素總數
*/
void print_subset(char **elems, int *pick, int n) {
    printf("(");
    int first = 1; // 控制輸出格式，避免多餘逗號
    for (int i = 0; i < n; ++i) {
        if (pick[i]) { // 若 pick[i] = 1，代表該元素被選取
            if (!first) printf(", "); // 在非第一個元素前加逗號
            printf("%s", elems[i]);
            first = 0;
        }
    }
    printf(")\n");
}

/* ====== 遞迴函數：逐個決定是否選取元素 ======
   - idx: 當前正在處理的元素索引
   - n: 元素總數
   - elems: 存放元素的字串陣列
   - pick: 紀錄當前子集合選擇情況的陣列
*/
void powerset_dfs(int idx, int n, char **elems, int *pick) {
    if (idx == n) { // 遞迴基底條件：所有元素皆處理完畢
        print_subset(elems, pick, n); // 輸出當前子集合
        return;
    }

    // 情況一：不選取 elems[idx]
    pick[idx] = 0;
    powerset_dfs(idx + 1, n, elems, pick);

    // 情況二：選取 elems[idx]
    pick[idx] = 1;
    powerset_dfs(idx + 1, n, elems, pick);
}

/* ====== 主程式 ====== */
int main() {
    int n;
    printf("輸入元素數量：");
    scanf("%d", &n);

    // 配置存放元素字串的陣列 (長度 = n)
    // 注意：若 n=0，仍配置至少一個位置，避免 malloc(0) 的不確定行為
    char **elems = (char**)malloc(sizeof(char*) * (n > 0 ? n : 1));

    // 為每個元素分配字元空間 (最多 63 字元 + '\0')
    for (int i = 0; i < n; ++i) {
        elems[i] = (char*)malloc(64);
    }

    // 輸入元素內容
    printf("請輸入 %d 個元素（以空白分隔）：\n", n);
    for (int i = 0; i < n; ++i) {
        scanf("%s", elems[i]);
    }

    // 配置 pick 陣列，用來記錄每個元素是否被選取
    int *pick = (int*)malloc(sizeof(int) * n);
    for (int i = 0; i < n; ++i) pick[i] = 0;

    // 呼叫遞迴函式，從索引 0 開始生成所有子集合
    printf("\n所有子集合 (Power set)：\n");
    powerset_dfs(0, n, elems, pick);

    // 釋放記憶體，避免記憶體洩漏
    for (int i = 0; i < n; ++i) free(elems[i]);
    free(elems);
    free(pick);

    return 0;
}

```

## 效能分析

1.時間複雜度：$O(n \times 2^n)$
2.空間複雜度：$O(n)$

## 測試與驗證
<img width="309" height="518" alt="image" src="https://github.com/user-attachments/assets/b29e2f42-eb5c-4e95-983a-bfba08d1a960" />



### 測試案例
| 測試案例 | 輸入集合 $S$      | 預期輸出 (Power Set)                                                              | 實際輸出                                                                 |
| ---- | ------------- | ----------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| 測試一  | $S = {A,B}$   | ${\ {}, {A}, {B}, {A,B}\ }$                                                   | `()`, `(B)`, `(A)`, `(A, B)`                                         |
| 測試二  | $S = {1,2,3}$ | 共 $2^3 = 8$ 個子集合 <br> ${\ {}, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}\ }$ | `()`, `(3)`, `(2)`, `(2, 3)`, `(1)`, `(1, 3)`, `(1, 2)`, `(1, 2, 3)` |



### 編譯與執行指令

```shell
$ gcc hw1_2.c -o hw1_2
$ ./hw1_2
```

### 結論
程式能正確產生輸入集合 $S$ 的所有子集合，並完整輸出 Power Set。
測試案例顯示，在小型集合（如 $S={A,B}$、$S={1,2,3}$）下，程式輸出結果與數學定義完全一致。
由於 Power Set 的規模為 $2^n$，輸入集合元素數量越大，輸出的子集合數量將呈指數成長，因此本程式適合用於展示遞迴列舉的概念，而不適合處理過大集合。
## 申論及開發報告

### 開發過程中的挑戰

1. 輸出格式
   在輸出子集合時，需要避免多餘的逗號或空格。
   透過設定 first 變數，能控制每個子集合中元素的輸出格式。
2. 記錄選擇狀態
   使用 pick[] 陣列來記錄當前子集合中哪些元素被選取。
   在遞迴基底情況 (idx == n) 時，讀取 pick[] 並輸出對應子集合。
3. 記憶體管理
   使用 malloc 分配字串陣列來存放元素。
   在程式結束前必須 free 所有配置的記憶體，避免記憶體洩漏。
## 心得
本題讓我體會到 遞迴與組合問題的天然契合。
雖然 Power Set 的輸出數量會隨著 $n$ 指數級成長，導致在大集合下不具實用性，但它非常適合用於理解遞迴程式設計的思維。
透過本次實作，我更加熟悉了：
如何用遞迴枚舉所有可能的組合；
如何設計輔助陣列（如 pick[]）來保存中間狀態；
如何控制輸出格式與釋放記憶體。
這題的價值在於 展示遞迴的威力，幫助我們學會將抽象數學定義轉換為清晰的程式流程。
